class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> t(n + 1); //To handle edge cases
        t[1] = 1; // First ugly number
        // Initialize t2, t3 & t5 with 1 to pointing the 1st ugly number
        int t2 = 1;
        int t3 = 1;
        int t5 = 1;
        for (int i = 2; i <= n; i++) {
            int second = t[t2] * 2;
            int third = t[t3] * 3;
            int fifth = t[t5] * 5;
            t[i] = min({second, third, fifth});
            if (t[i] == second) {
                t2++;
            }
            if (t[i] == third) {
                t3++;
            }
            if (t[i] == fifth) {
                t5++;
            }
        }
        return t[n];
    }
};

// Intuition
// The problem at hand is to find the n-th "ugly number." An ugly number is defined as a number whose only prime factors are 2, 3, or 5. The idea here is to generate ugly numbers in a sequential manner.

// Approach
// Initialization:
// • A vector t of size n+1 is used to store the first n ugly numbers, with t[1] initialized to 1 (since 1 is considered the first ugly number).
// • Three pointers, t2, t3, and t5, are used to keep track of the position in the list for generating the next ugly number by multiplying by 2, 3, and 5, respectively.
// Generating Ugly Numbers:
// • In each iteration, compute potential next ugly numbers by multiplying the current values pointed to by t2, t3, and t5 with 2, 3, and 5, respectively.
// • The next ugly number t[i] is the minimum of these potential values.
// • Update the pointers t2, t3, and t5 as needed:
// o If t[i] matches the value generated by multiplying t[t2] by 2, increment t2.
// o If t[i] matches the value generated by multiplying t[t3] by 3, increment t3.
// o If t[i] matches the value generated by multiplying t[t5] by 5, increment t5.
// Return:
// • After the loop completes, t[n] will be the nnn-th ugly number.
// Complexity
// Time complexity:
//     The time complexity of this approach is O(n).
// Space complexity:
//     O(n)
